require('app-module-path').addPath(__dirname + '/../../') // eslint-disable-line

/**
 * External dependencies
 */
const test = require('ava')
const sinon = require('sinon')
const Promise = require('bluebird')
const proxyquire = require('proxyquire')

/**
 * Stubs
 */
const signAsyncStub = sinon.stub().returns(Promise.resolve('test-token'))
const errorStub = sinon.stub()
const catchError = new Error('test')
const testPasswordInput = 'password'

/**
 * SUT
 */
const authorization = proxyquire('src/lib/authorization', {
  'bluebird': {
    promisifyAll: () => {}
  },
  'jsonwebtoken': {
    signAsync: signAsyncStub
  },
  'winston': {
    error: errorStub
  }
})

test.beforeEach(() => {
  signAsyncStub.reset()
})

test('generateToken: returns a jwt token', t =>
  authorization.generateToken({ id: 1, email: 'test@test.com' })
    .then(token => t.is(token, 'test-token')))

test('generateToken: logs before throwing again', async t => {
  signAsyncStub.returns(Promise.reject(catchError))
  t.plan(3)

  const error = await t.throws(authorization.generateToken({ id: 1 }))

  t.is(error, catchError)
  t.not(errorStub.args[0][0].indexOf(catchError.message), -1)
})

test('generateToken: throws if neither id nor email are present', async t => {
  const { message } = await t.throws(authorization.generateToken({}))

  t.is(message, 'id or email required')
})

test('generatePasswordHash: returns hashed password', t =>
  authorization.generatePasswordHash(testPasswordInput)
    .then(({ password }) => t.true(password.length > 12)))

test('generatePasswordHash: returns salt used to hash password', t =>
  authorization.generatePasswordHash(testPasswordInput)
    .then(({ salt }) => t.true(salt.length > 30)))

test('verifyPassword: verifies a password generated by itself', t =>
  authorization.generatePasswordHash(testPasswordInput)
    .then(({ password, salt }) => authorization.verifyPassword(password, testPasswordInput)))

test('verifyPassword: throws if password not verified', async t => {
  const { password } = await authorization.generatePasswordHash(testPasswordInput)
  const { message } = await t.throws(authorization.verifyPassword(password, 'incorrect password input'))

  t.is(message, 'unauthorized')
})
